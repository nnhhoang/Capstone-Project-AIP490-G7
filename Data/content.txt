Contents
1 Why should you learn to write programs? 1
1.1 Creativity and motivation . . . . . . . . . . . . . . . . . . . . . . . 2
1.2 Computer hardware architecture . . . . . . . . . . . . . . . . . . . 3
1.3 Understanding programming . . . . . . . . . . . . . . . . . . . . . 4
1.4 Words and sentences . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.5 Conversing with Python . . . . . . . . . . . . . . . . . . . . . . . . 6
1.6 Terminology: Interpreter and compiler . . . . . . . . . . . . . . . . 8
1.7 Writing a program . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.8 What is a program? . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.9 The building blocks of programs . . . . . . . . . . . . . . . . . . . 11
1.10 What could possibly go wrong? . . . . . . . . . . . . . . . . . . . . 12
1.11 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
1.12 The learning journey . . . . . . . . . . . . . . . . . . . . . . . . . . 15
1.13 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
1.14 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
2 Variables, expressions, and statements 19
2.1 Values and types . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
2.2 Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.3 Variable names and keywords . . . . . . . . . . . . . . . . . . . . . 21
2.4 Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
2.5 Operators and operands . . . . . . . . . . . . . . . . . . . . . . . . 22
2.6 Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.7 Order of operations . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.8 Modulus operator . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
2.9 String operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
vvi CONTENTS
2.10 Asking the user for input . . . . . . . . . . . . . . . . . . . . . . . 25
2.11 Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
2.12 Choosing mnemonic variable names . . . . . . . . . . . . . . . . . 27
2.13 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
2.14 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
2.15 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
3 Conditional execution 31
3.1 Boolean expressions . . . . . . . . . . . . . . . . . . . . . . . . . . 31
3.2 Logical operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
3.3 Conditional execution . . . . . . . . . . . . . . . . . . . . . . . . . 32
3.4 Alternative execution . . . . . . . . . . . . . . . . . . . . . . . . . 34
3.5 Chained conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . 34
3.6 Nested conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . 35
3.7 Catching exceptions using try and except . . . . . . . . . . . . . . 36
3.8 Short-circuit evaluation of logical expressions . . . . . . . . . . . . 38
3.9 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
3.10 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
3.11 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
4 Functions 43
4.1 Function calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
4.2 Built-in functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
4.3 Type conversion functions . . . . . . . . . . . . . . . . . . . . . . . 44
4.4 Math functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
4.5 Random numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
4.6 Adding new functions . . . . . . . . . . . . . . . . . . . . . . . . . 47
4.7 Deﬁnitions and uses . . . . . . . . . . . . . . . . . . . . . . . . . . 48
4.8 Flow of execution . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
4.9 Parameters and arguments . . . . . . . . . . . . . . . . . . . . . . 49
4.10 Fruitful functions and void functions . . . . . . . . . . . . . . . . . 51
4.11 Why functions? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
4.12 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
4.13 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
4.14 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54CONTENTS vii
5 Iteration 57
5.1 Updating variables . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
5.2 The while statement . . . . . . . . . . . . . . . . . . . . . . . . . 57
5.3 Inﬁnite loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
5.4 Finishing iterations with continue . . . . . . . . . . . . . . . . . . 59
5.5 Deﬁnite loops using for. . . . . . . . . . . . . . . . . . . . . . . . 60
5.6 Loop patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
5.6.1 Counting and summing loops . . . . . . . . . . . . . . . . . 61
5.6.2 Maximum and minimum loops . . . . . . . . . . . . . . . . 62
5.7 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
5.8 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
5.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
6 Strings 67
6.1 A string is a sequence . . . . . . . . . . . . . . . . . . . . . . . . . 67
6.2 Getting the length of a string using len . . . . . . . . . . . . . . . 68
6.3 Traversal through a string with a loop . . . . . . . . . . . . . . . . 68
6.4 String slices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
6.5 Strings are immutable . . . . . . . . . . . . . . . . . . . . . . . . . 70
6.6 Looping and counting . . . . . . . . . . . . . . . . . . . . . . . . . 70
6.7 The inoperator . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
6.8 String comparison . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
6.9 String methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
6.10 Parsing strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
6.11 Formatted String Literals . . . . . . . . . . . . . . . . . . . . . . . 74
6.12 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
6.13 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
6.14 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
7 Files 79
7.1 Persistence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
7.2 Opening ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
7.3 Text ﬁles and lines . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
7.4 Reading ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
7.5 Searching through a ﬁle . . . . . . . . . . . . . . . . . . . . . . . . 83viii CONTENTS
7.6 Letting the user choose the ﬁle name . . . . . . . . . . . . . . . . . 85
7.7 Using try, except, andopen . . . . . . . . . . . . . . . . . . . . 86
7.8 Writing ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
7.9 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
7.10 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
7.11 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
8 Lists 91
8.1 A list is a sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
8.2 Lists are mutable . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
8.3 Traversing a list . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
8.4 List operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
8.5 List slices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
8.6 List methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
8.7 Deleting elements . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
8.8 Lists and functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
8.9 Lists and strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
8.10 Parsing lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
8.11 Objects and values . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
8.12 Aliasing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
8.13 List arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
8.14 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
8.15 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
8.16 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
9 Dictionaries 109
9.1 Dictionary as a set of counters . . . . . . . . . . . . . . . . . . . . 111
9.2 Dictionaries and ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . 112
9.3 Looping and dictionaries . . . . . . . . . . . . . . . . . . . . . . . 114
9.4 Advanced text parsing . . . . . . . . . . . . . . . . . . . . . . . . . 115
9.5 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
9.6 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
9.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117CONTENTS ix
10 Tuples 119
10.1 Tuples are immutable . . . . . . . . . . . . . . . . . . . . . . . . . 119
10.2 Comparing tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
10.3 Tuple assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
10.4 Dictionaries and tuples . . . . . . . . . . . . . . . . . . . . . . . . 123
10.5 Multiple assignment with dictionaries . . . . . . . . . . . . . . . . 124
10.6 The most common words . . . . . . . . . . . . . . . . . . . . . . . 125
10.7 Using tuples as keys in dictionaries . . . . . . . . . . . . . . . . . . 126
10.8 Sequences: strings, lists, and tuples - Oh My! . . . . . . . . . . . . 126
10.9 List comprehension . . . . . . . . . . . . . . . . . . . . . . . . . . 127
10.10 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
10.11 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
10.12 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
11 Regular expressions 131
11.1 Character matching in regular expressions . . . . . . . . . . . . . . 132
11.2 Extracting data using regular expressions . . . . . . . . . . . . . . 133
11.3 Combining searching and extracting . . . . . . . . . . . . . . . . . 136
11.4 Escape character . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
11.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
11.6 Bonus section for Unix / Linux users . . . . . . . . . . . . . . . . . 141
11.7 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
11.8 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
11.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
12 Networked programs 145
12.1 Hypertext Transfer Protocol - HTTP . . . . . . . . . . . . . . . . 145
12.2 The world’s simplest web browser . . . . . . . . . . . . . . . . . . 146
12.3 Retrieving an image over HTTP . . . . . . . . . . . . . . . . . . . 148
12.4 Retrieving web pages with urllib . . . . . . . . . . . . . . . . . . 150
12.5 Reading binary ﬁles using urllib . . . . . . . . . . . . . . . . . . 151
12.6 Parsing HTML and scraping the web . . . . . . . . . . . . . . . . 152
12.7 Parsing HTML using regular expressions . . . . . . . . . . . . . . 152
12.8 Parsing HTML using BeautifulSoup . . . . . . . . . . . . . . . . . 154
12.9 Bonus section for Unix / Linux users . . . . . . . . . . . . . . . . . 157
12.10 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
12.11 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158x CONTENTS
13 Using Web Services 159
13.1 eXtensible Markup Language - XML . . . . . . . . . . . . . . . . . 159
13.2 Parsing XML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
13.3 Looping through nodes . . . . . . . . . . . . . . . . . . . . . . . . 161
13.4 JavaScript Object Notation - JSON . . . . . . . . . . . . . . . . . 162
13.5 Parsing JSON . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
13.6 Application Programming Interfaces . . . . . . . . . . . . . . . . . 164
13.7 Security and API usage . . . . . . . . . . . . . . . . . . . . . . . . 165
13.8 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166
13.9 Google geocoding web service . . . . . . . . . . . . . . . . . . . . . 166
14 Object-oriented programming 171
14.1 Managing larger programs . . . . . . . . . . . . . . . . . . . . . . . 171
14.2 Getting started . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
14.3 Using objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
14.4 Starting with programs . . . . . . . . . . . . . . . . . . . . . . . . 173
14.5 Subdividing a problem . . . . . . . . . . . . . . . . . . . . . . . . . 175
14.6 Our ﬁrst Python object . . . . . . . . . . . . . . . . . . . . . . . . 175
14.7 Classes as types . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
14.8 Object lifecycle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
14.9 Multiple instances . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
14.10 Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
14.11 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
14.12 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
15 Using Databases and SQL 185
15.1 What is a database? . . . . . . . . . . . . . . . . . . . . . . . . . . 185
15.2 Database concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
15.3 Database Browser for SQLite . . . . . . . . . . . . . . . . . . . . . 186
15.4 Creating a database table . . . . . . . . . . . . . . . . . . . . . . . 186
15.5 Structured Query Language summary . . . . . . . . . . . . . . . . 189
15.6 Multiple tables and basic data modeling . . . . . . . . . . . . . . . 191
15.7 Data model diagrams . . . . . . . . . . . . . . . . . . . . . . . . . 193
15.8 Automatically creating primary keys . . . . . . . . . . . . . . . . . 194
15.9 Logical keys for fast lookup . . . . . . . . . . . . . . . . . . . . . . 195CONTENTS xi
15.10 Adding constraints to the data database . . . . . . . . . . . . . . . 196
15.11 Sample multi-table application . . . . . . . . . . . . . . . . . . . . 197
15.12 Many to many relationships in databases . . . . . . . . . . . . . . 200
15.13 Modeling data at the many-to-many connection . . . . . . . . . . 204
15.14 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
15.15 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
15.16 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
16 Visualizing data 209
16.1 Building a OpenStreetMap from geocoded data . . . . . . . . . . . 209
16.2 Visualizing networks and interconnections . . . . . . . . . . . . . . 211
16.3 Visualizing mail data . . . . . . . . . . . . . . . . . . . . . . . . . 214
A Contributions 221
A.1 Translations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
A.2 Contributor List for Python for Everybody . . . . . . . . . . . . . 221
A.3 Contributor List for Python for Informatics . . . . . . . . . . . . . 222
A.4 Preface for “Think Python” . . . . . . . . . . . . . . . . . . . . . . 222
A.4.1 The strange history of “Think Python” . . . . . . . . . . . 222
A.4.2 Acknowledgements for “Think Python” . . . . . . . . . . . 223
A.5 Contributor List for “Think Python” . . . . . . . . . . . . . . . . . 224